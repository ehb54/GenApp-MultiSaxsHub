#! /usr/local/bin/node 

// ----------------------------------------------------------------------------------------------------------
// background
// ----------------------------------------------------------------------------------------------------------
// runs crysol one time in various scan modes
// notes are a work in progress, added to as needed by discovery
// ----------------------------------------------------------------------------------------------------------
// summary of data structures
// ----------------------------------------------------------------------------------------------------------
// hard-coded:
// app_texts_calc - object of texts for interacting with command line mode of CRYSOL
// app_texts_fit  - object of texts for interacting with command line mode of CRYSOL
// app_texts_scan - object of texts for interacting with command line mode of CRYSOL
// scan_table     - object of scan types and their mode/low/high/interval/points/scale for lookups

// ----------------------------------------------------------------------------------------------------------
// summary of functions
// ----------------------------------------------------------------------------------------------------------
// crysol_runner()               - main entry point,
//                               - calls calc_runner(), fit_runner() or scan_runner()
// initialize()                  - processes data in request and adjusts values in apt_texts_{calc,fit,scan} to populate with req values
//                               - called by crysol_runner()
// scanning components:
// scan_runner()                 - starts scan running
//                               - calls setup_scan(), generate_scan_array(), readfile_log(), spawn_scan_runner(), write_chi2()
// setup_scan()                  - populates arrays scan_variables* 
//                               - called by scan_runner()
// generate_scan_array()         - generates a set of indices for spawn_scan_runner()
//                               - this is where we not initialize scandata parameter vectors
//                               - called by scan_runner()
// spawn_scan_runner()           - runs the scan
//                               - calls get_response_scan_runner() on stdout receipts
// get_response_scan_runner()    - handles stdout & builds response for stdin
//                               - calls set_scan_variables_scanner()
// set_scan_variables_scanner()  - sets variables from index array, appears the one is (set -1) is allowed to float


const debug         = false;
var   scandata_mode = false;

dmsg = function( msg ) {
    if ( !debug ) {
        return false;
    }
    console.log( msg );
    return true;
}

const fs                                       = require('fs');
const util                                     = require('util');
promisify                                      = util.promisify;
const spawn                                    = require('child_process').spawn;
const exec                                     = require('child_process').exec;
//const exec                                     =  require('child_process').fork;
const p_exec                                   = promisify( require( 'child_process' ).exec ) ;

const { PerformanceObserver, performance }     = require('perf_hooks');
const scandata                                 = require( "./scandata.js" );

var input_from_ui                              = process.argv[ 2 ];
var req_original                               = JSON.parse( input_from_ui );

const cmdpath                                  = __dirname + '/';

var cmd                                        = cmdpath + "crysolcmd";

const string_expdata                           = "experimental_curve";
const string_pdb                               = "pdb";

var pdb                                        = req_original[ string_pdb ].join( " " );
var pdbshort                                   = pdb.split('/').slice(-1).pop();
var pdbbase                                    = pdbshort.replace( /\.pdb$/i, '');
var runname                                    = req_original.runname;
var expdata                                    = "";
var expdatashort                               = "";

// Decide run mode and update run mode specific options in app_texts

var runmode                                    = "calc";
var startTime                                  = 0.0;

// extract value from the array in the original req
var req                                        = {};
var prefix_req                                 = [];

for ( x in req_original ) {
    prefix_req.push( x.split('_').slice(0,1).toString() );
    if ( Array.isArray(req_original[ x ]) ) {
        if ( x == string_expdata ) {
            req[ x ] = req_original[ x ];
        } else {
            var new_value = req_original[ x ].pop();
            req[ x ] = new_value;
        };
    } else {
        req[ x ] = req_original[ x ];
    };
};

//console.log ( prefix_req + "\n" );

// Update app_texts using user input

var raw_expdata                                = "";
var raw_expdatashort                           = "";

function initialize() {

    if ( string_expdata in req ) {
        raw_expdata += req[ string_expdata ].join( " " );
        raw_expdatashort = raw_expdata.split('/').slice(-1).pop();
        
        if ( prefix_req.includes( "scan" ) ) {
            runmode = "scan";
        } else  {
            runmode = "fit";
        };
    };

    if ( runmode == "calc" ) {
        for ( opt in app_texts_calc ) {
            if ( opt in req ) {
                if ( opt == string_pdb ){
                    app_texts_calc[ opt ][ "response" ] = pdbshort;
                } else if ( opt == "angular_units"){
                    app_texts_calc[ opt ][ "response" ] = angular_units[ "CRYSOL" ][ req[ opt ] ];
                } else if ( app_texts_calc[ opt ][ "type" ] == "checkbox" ) { 
                    app_texts_calc[ opt ][ "response" ] = "Y";
                } else { 
                    app_texts_calc[ opt ][ "response" ] = req[ opt ];    
                };
            };
            if ( "id" in app_texts_calc[ opt ] && opt in req ) {
                for ( var i=0; i < app_texts_calc[ opt ][ "id" ].length; i++ ) { 
                    app_texts_calc[ app_texts_calc[ opt ][ "id" ][ i ] ][ "response" ] = req[ opt ];
                };
            }; 
        };
        temp_response = JSON.parse( JSON.stringify ( app_texts_calc ) );
    } else if ( runmode == "fit" ) {
        for ( opt in app_texts_fit ) {
            if ( opt in req ) {
                if ( opt == string_pdb ){
                    app_texts_fit[ opt ][ "response" ] = pdbshort;
                } else if ( opt == string_expdata ) {
                    expdatashort = "tmp_" + raw_expdatashort;
                    app_texts_fit[ opt ][ "response" ] = expdatashort;
                } else if ( opt == "angular_units"){
                    app_texts_fit[ opt ][ "response" ] = angular_units[ "CRYSOL" ][ req[ opt ] ];
                } else if ( app_texts_fit[ opt ][ "type" ] == "checkbox" ) {
                    app_texts_fit[ opt ][ "response" ] = "Y";
                } else {
                    app_texts_fit[ opt ][ "response" ] = req[ opt ];
                };
            };
            if ( "id" in app_texts_fit[ opt ] && opt in req ) {
                console.log ( app_texts_fit[ opt ] );
                var temp_id = app_texts_fit[ opt ][ "id" ];
                //console.log ( req[ temp_id ] );
                for ( var i=0; i < app_texts_fit[ opt ][ "id" ].length; i++ ) {
                    app_texts_fit[ app_texts_fit[ opt ][ "id" ][ i ] ][ "response" ] = req[ opt ];
                };
            };
        };

        temp_response = JSON.parse( JSON.stringify ( app_texts_fit ) );
        
    } else if ( runmode == "scan" ) {
        for ( opt in app_texts_scan ) {
            if ( opt in req ) {
                if ( opt == string_pdb ){
                    app_texts_scan[ opt ][ "response" ] = pdbshort;
                } else if ( opt == string_expdata ) {
                    expdatashort =  "tmp_" + raw_expdatashort;
                    app_texts_scan[ opt ][ "response" ] = expdatashort;
                } else if ( opt == "angular_units"){
                    app_texts_scan[ opt ][ "response" ] = angular_units[ "CRYSOL" ][ req[ opt ] ];
                } else if ( app_texts_scan[ opt ][ "type" ] == "checkbox" ) {
                    if ( opt == "constant_subtractions" ) { 
                        app_texts_scan[ opt ][ "response" ] = "N";
                    } else {
                        app_texts_scan[ opt ][ "response" ] = "Y";
                    };
                } else {
                    app_texts_scan[ opt ][ "response" ] = req[ opt ];
                };
            };
            // Check if scan variable options == 5: Mode 5 is definded as ratio
            var opt_mode5 = opt + "_ratio";
            if ( opt_mode5 in req ) {
                app_texts_scan[ opt ][ "response" ] = req[ opt_mode5 ];
            };

            if ( "id" in app_texts_scan[ opt ] && opt in req ) {
                //console.log ( app_texts_scan[ opt ] );
                var temp_id = app_texts_scan[ opt ][ "id" ];
                //console.log ( req[ temp_id ] );
                for ( var i=0; i < app_texts_scan[ opt ][ "id" ].length; i++ ) {
                    app_texts_scan[ app_texts_scan[ opt ][ "id" ][ i ] ][ "response" ] = req[ opt ];
                };
            };
        };
        app_texts_scan[ "set_parameters" ][ "response" ] = "Y";
        temp_response = JSON.parse( JSON.stringify ( app_texts_scan ) );

    };
    console.log(JSON.stringify ( temp_response, null, 2 ) );
}

function get_response_calc_runner(response_update, source, res, maxscansteps ) {
    var response = '';
    var resstring = res.replace(/\s+/g,'').replace(/\h+/g,'').replace(/\-+/g,'');

    for ( opt in response_update) {
        var optstring = response_update[ opt ][ "text" ].replace(/\s+/g,'').replace(/\h+/g,'');
        if ( resstring.indexOf(optstring) >= 0 ) {
            //if ( opt == "set_parameters" ) {
            //    response = "N";
            //} else {
            response += response_update[ opt ][ "response" ].toString();
            //};
            source.stdin.write(response + "\n");
            console.log ( res + response + "\n");
            //console.log ( response +  "\n");
        };
    };
    return response;
}

function get_response_fit_runner(response_update, source, res, maxscansteps ) {
    var response = '';
    var resstring = res.replace(/\s+/g,'').replace(/\h+/g,'').replace(/\-+/g,'');

    for ( opt in response_update) {
        var optstring = response_update[ opt ][ "text" ].replace(/\s+/g,'').replace(/\h+/g,'');
        if ( resstring.indexOf(optstring) >= 0 ) {
            if ( opt == "set_parameters" ) {
                response = "Y";
                var currentstep = temp_response[ opt ][ "min" ] ;
                if ( currentstep > maxscansteps ) {
                    response = "N";
                };
                //console.log ( opt + " :" + response + " " + currentstep + "\n" );
                temp_response[ opt ][ "min" ] += 1;
                currentstep += 1;
            } else {
                response = temp_response[ opt ][ "response" ].toString();
            };
            source.stdin.write(response + "\n");
            console.log ( res + response + "\n");
        };
    };
    return response;
}

function scan_parameter_report( res  ) {

    //    console.log ("## Scan parameters = " + JSON.stringify( scan_variables) ); 
    dmsg( `--> scan_parameter_report() res is \n-->'${res}'` );

    if ( req[ "excluded_volume_mode" ] == "5" ){
        var scale_ev_volume = parseFloat( res.substring(res.indexOf("V" ) + 4, res.indexOf("V" ) + 10 ) );
        app_texts_scan[ "scan_excluded_volume_low" ][ "response" ] *= scale_ev_volume;
        app_texts_scan[ "scan_excluded_volume_high" ][ "response" ] *= scale_ev_volume;
        app_texts_scan[ "scan_excluded_volume_interval" ][ "response" ] *= scale_ev_volume;
        console.log ("## Excluded volume(Vol) is scan parameter" );
        console.log ("## Vol_predicted  = " + scale_ev_volume + " A^3");
        console.log ("## Vol_min        = " + ( temp_response[ "scan_excluded_volume_low" ][ "response" ] * scale_ev_volume ).toFixed(1) + " A^3");
        console.log ("## Vol_max        = " + ( temp_response[ "scan_excluded_volume_high" ][ "response" ] * scale_ev_volume ).toFixed(1) + " A^3");
        console.log ("## Vol_interval   = " + ( temp_response[ "scan_excluded_volume_interval" ][ "response" ] * scale_ev_volume ).toFixed(1) + " A^3");
        console.log ("## Vol_points     = " + temp_response[ "scan_excluded_volume_points" ][ "response" ] + "\n" ) ;
        console.log ("## ");
    } else if ( req[ "excluded_volume_mode" ] == "4" ) {
        var scale_ev_volume = parseFloat( res.substring(res.indexOf("V" ) + 4, res.indexOf("V" ) + 10 ) );
        console.log ("## Excluded volume(Vol) is scan parameter" );
        console.log ("## Vol_predicted  = " + scale_ev_volume + " A^3");
        console.log ("## Vol_min        = " + ( temp_response[ "scan_excluded_volume_low" ][ "response" ] * 1.0 ).toFixed(1) + " A^3");
        console.log ("## Vol_max        = " + ( temp_response[ "scan_excluded_volume_high" ][ "response" ] * 1.0 ).toFixed(1)+ " A^3" );
        console.log ("## Vol_interval   = " + ( temp_response[ "scan_excluded_volume_interval" ][ "response" ] * 1.0 ).toFixed(1)+ " A^3" );
        console.log ("## Vol_points     = " + temp_response[ "scan_excluded_volume_points" ][ "response" ] + "\n" ) ;
        console.log ("## ");
    } else if ( req[ "excluded_volume_mode" ] == "3" ) {
        var scale_ev_volume = parseFloat( res.substring(res.indexOf("V" ) + 4, res.indexOf("V" ) + 10 ) );
        console.log ("## Excluded volume(Vol) will be optimized during scan" );
        console.log ("## Vol_predicted  = " + scale_ev_volume + " A^3");
        console.log ("## Vol_min        = " + ( temp_response[ "scan_excluded_volume_low" ][ "response" ] * 1.0 ).toFixed(1) + " A^3" );
        console.log ("## Vol_max        = " + ( temp_response[ "scan_excluded_volume_high" ][ "response" ] * 1.0 ).toFixed(1)+ " A^3" + "\n" );
        console.log ("## ");
    } else if ( req[ "excluded_volume_mode" ] == "2" ) {
        var scale_ev_volume = parseFloat( res.substring(res.indexOf("V" ) + 4, res.indexOf("V" ) + 10 ) );
        console.log ("## Excluded volume(Vol) will be fixed during scan" );
        console.log ("## Vol_predicted  = " + scale_ev_volume + " A^3");
        console.log ("## Vol_fixed      = " + ( temp_response[ "scan_excluded_volume_low" ][ "response" ] * 1.0 ).toFixed(1) + " A^3" + "\n" );
        console.log ("## ");
    } else if ( req[ "excluded_volume_mode" ] == "1" ) {
        var scale_ev_volume = parseFloat( res.substring(res.indexOf("V" ) + 4, res.indexOf("V" ) + 10 ) );
        console.log ("## Excluded volume(Vol) will be optimized during scan" );
        console.log ("## Vol_predicted  = " + scale_ev_volume + " A^3");
        console.log ("## Vol_min        = " + ( temp_response[ "scan_excluded_volume_low" ][ "response" ] * 1.0 ).toFixed(1) + " A^3" );
        console.log ("## Vol_max        = " + ( temp_response[ "scan_excluded_volume_high" ][ "response" ] * 1.0 ).toFixed(1)+ " A^3" + "\n" );
        console.log ("## ");
    };
    if ( req[ "atomic_radius_mode" ] == "5" ){
        var scale_ra = parseFloat( res.substring(res.indexOf("R" ) + 3, res.indexOf("R" ) + 9 ) );
        app_texts_scan[ "scan_atomic_radius_low" ][ "response" ] *= scale_ra;
        app_texts_scan[ "scan_atomic_radius_high" ][ "response" ] *= scale_ra;
        app_texts_scan[ "scan_atomic_radius_interval" ][ "response" ] *= scale_ra;
        console.log ("## Atomic radius(Ra) is scan parameter" );
        console.log ("## Ra_predicted   = " + scale_ra + " A" );
        console.log ("## Ra_min         = " + ( temp_response[ "scan_atomic_radius_low" ][ "response" ] * scale_ra ).toFixed(3) + " A" );
        console.log ("## Ra_max         = " + ( temp_response[ "scan_atomic_radius_high" ][ "response" ] * scale_ra ).toFixed(3) + " A" );
        console.log ("## Ra_interval    = " + ( temp_response[ "scan_atomic_radius_interval" ][ "response" ] * scale_ra ).toFixed(3) + " A" + "\n" );
        console.log ("## Ra_points     = " + temp_response[ "scan_atomic_radius_points" ][ "response" ] + "\n" ) ;
        console.log ("## ");
    } else if ( req[ "atomic_radius_mode" ] == "4" ) {
        var scale_ra = parseFloat( res.substring(res.indexOf("R" ) + 3, res.indexOf("R" ) + 9 ) );
        console.log ("## Atomic radius(Ra) is scan parameter" );
        console.log ("## Ra_predicted   = " + scale_ra + " A" );
        console.log ("## Ra_min         = " + ( temp_response[ "scan_atomic_radius_low" ][ "response" ] * 1.0 ).toFixed(3) + " A" );
        console.log ("## Ra_max         = " + ( temp_response[ "scan_atomic_radius_high" ][ "response" ] * 1.0 ).toFixed(3) + " A" );
        console.log ("## Ra_interval    = " + ( temp_response[ "scan_atomic_radius_interval" ][ "response" ] * 1.0 ).toFixed(3) + " A" + "\n" );
        console.log ("## Ra_points     = " + temp_response[ "scan_atomic_radius_points" ][ "response" ] + "\n" ) ;
        console.log ("## ");
    } else if ( req[ "atomic_radius_mode" ] == "3" ) {
        var scale_ra = parseFloat( res.substring(res.indexOf("R" ) + 3, res.indexOf("R" ) + 9 ) );
        console.log ("## Atomic radius(Ra) will be optimized during scan" );
        console.log ("## Ra_predicted   = " + scale_ra + " A" );
        console.log ("## Ra_min         = " + ( temp_response[ "scan_atomic_radius_low" ][ "response" ] * 1.0 ).toFixed(3) + " A" );
        console.log ("## Ra_max         = " + ( temp_response[ "scan_atomic_radius_high" ][ "response" ] * 1.0 ).toFixed(3) + " A" + "\n" );
        console.log ("## ");
    } else if ( req[ "atomic_radius_mode" ] == "2" ) {
        var scale_ra = parseFloat( res.substring(res.indexOf("R" ) + 3, res.indexOf("R" ) + 9 ) );
        console.log ("## Atomic radius(Ra) will be fixed during scan" );
        console.log ("## Ra_predicted   = " + scale_ra + " A" );
        console.log ("## Ra_fixed         = " + ( temp_response[ "scan_atomic_radius_low" ][ "response" ] * 1.0 ).toFixed(3) + " A" + "\n" );
        console.log ("## ");
    } else if ( req[ "atomic_radius_mode" ] == "1" ) {
        var scale_ra = parseFloat( res.substring(res.indexOf("R" ) + 3, res.indexOf("R" ) + 9 ) );
        console.log ("## Atomic radius(Ra) will be optimized during scan" );
        console.log ("## Ra_predicted   = " + scale_ra + " A" );
        console.log ("## Ra_min         = " + ( temp_response[ "scan_atomic_radius_low" ][ "response" ] * 1.0 ).toFixed(3) + " A" );
        console.log ("## Ra_max         = " + ( temp_response[ "scan_atomic_radius_high" ][ "response" ] * 1.0 ).toFixed(3) + " A" + "\n" );
        console.log ("## ");
    };
    if ( req[ "contrast_hydration_mode" ] == "5" ){
        var scale_dro = parseFloat( res.substring(res.indexOf("Dro" ) + 4, res.indexOf("Dro" ) + 10 ) );
        app_texts_scan[ "scan_contrast_hydration_low" ][ "response" ] *= scale_dro;
        app_texts_scan[ "scan_contrast_hydration_high" ][ "response" ] *= scale_dro;
        app_texts_scan[ "scan_contrast_hydration_interval" ][ "response" ] *= scale_dro;
        console.log ("## Contrast of hydration shell(Dro) is scan parameter" );
        console.log ("## Dro_predicted  = " + scale_dro + " e/A^3" );
        console.log ("## Dro_min        = " + ( temp_response[ "scan_contrast_hydration_low" ][ "response" ] * scale_dro ).toFixed(4) + " e/A^3" );
        console.log ("## Dro_max        = " + ( temp_response[ "scan_contrast_hydration_high" ][ "response" ] * scale_dro ).toFixed(4) + " e/A^3" );
        console.log ("## Dro_interval   = " + ( temp_response[ "scan_contrast_hydration_interval" ][ "response" ] * scale_dro ).toFixed(4) + " e/A^3" + "\n" );
        console.log ("## Dro_points     = " + temp_response[ "scan_contrast_hydration_points" ][ "response" ] + "\n" ) ;
        console.log ("## ");
    } else if ( req[ "contrast_hydration_mode" ] == "4" ) {
        var scale_dro = parseFloat( res.substring(res.indexOf("Dro" ) + 4, res.indexOf("Dro" ) + 10 ) );
        console.log ("## Contrast of hydration shell(Dro) is scan parameter" );
        console.log ("## Dro_predicted  = " + scale_dro + " e/A" );
        console.log ("## Dro_min      = " + ( temp_response[ "scan_contrast_hydration_low" ][ "response" ] * 1.0 ).toFixed(4) + " e/A^3" );
        console.log ("## Dro_max      = " + ( temp_response[ "scan_contrast_hydration_high" ][ "response" ] * 1.0 ).toFixed(4) + " e/A^3" );
        console.log ("## Dro_interval = " + ( temp_response[ "scan_contrast_hydration_interval" ][ "response" ] * 1.0 ).toFixed(4) + " e/A^3" + "\n" );
        console.log ("## Dro_points     = " + temp_response[ "scan_contrast_hydration_points" ][ "response" ] + "\n" ) ;
        console.log ("## ");
    } else if ( req[ "contrast_hydration_mode" ] == "3" ) {
        var scale_dro = parseFloat( res.substring(res.indexOf("Dro" ) + 4, res.indexOf("Dro" ) + 10 ) );
        console.log ("## Contrast of hydration shell(Dro) will be optimized during scan" );
        console.log ("## Dro_predicted  = " + scale_dro + " e/A" );
        console.log ("## Dro_min      = " + ( temp_response[ "scan_contrast_hydration_low" ][ "response" ] * 1.0 ).toFixed(4) + " e/A^3" );
        console.log ("## Dro_max      = " + ( temp_response[ "scan_contrast_hydration_high" ][ "response" ] * 1.0 ).toFixed(4) + " e/A^3" + "\n" );
        console.log ("## ");
    } else if ( req[ "contrast_hydration_mode" ] == "2" ) {
        var scale_dro = parseFloat( res.substring(res.indexOf("Dro" ) + 4, res.indexOf("Dro" ) + 10 ) );
        console.log ("## Contrast of hydration shell(Dro) will be fixed during scan" );
        console.log ("## Dro_predicted  = " + scale_dro + " e/A" );
        console.log ("## Dro_fixed      = " + ( temp_response[ "scan_contrast_hydration_low" ][ "response" ] * 1.0 ).toFixed(4) + " e/A^3" + "\n" );
        console.log ("## ");
    } else if ( req[ "contrast_hydration_mode" ] == "1" ) {
        var scale_dro = parseFloat( res.substring(res.indexOf("Dro" ) + 4, res.indexOf("Dro" ) + 10 ) );
        console.log ("## Contrast of hydration shell(Dro) will be optimized during scan" );
        console.log ("## Dro_predicted  = " + scale_dro + " e/A" );
        console.log ("## Dro_min      = " + ( temp_response[ "scan_contrast_hydration_low" ][ "response" ] * 1.0 ).toFixed(4) + " e/A^3" );
        console.log ("## Dro_max      = " + ( temp_response[ "scan_contrast_hydration_high" ][ "response" ] * 1.0 ).toFixed(4) + " e/A^3" + "\n" );
        console.log ("## ");
    };

}

var last_chi2;
var last_chi2_res_line;
var last_chi2_avail = false;

async function get_response_scan_runner(source, res, ndx_scan, maxscansteps ) {
    var response = '';
    var resstring = res.replace(/\s+/g,'').replace(/\h+/g,'').replace(/\-+/g,'');

    0 && dmsg( "get_response_scan_runner()" );
    dmsg( "get_response_scan_runner() : res now       : " + res );
    0 && dmsg( "get_response_scan_runner() : resstring now : " + resstring );
    
    if ( /Chi\^2:/.test(res) ) {
        if ( last_chi2_avail ) {
            console.error( "--> chi^2 found but last value is still available" );
        } else {
            last_chi2          = res.replace( /^.*Chi\^2:\s*/, '' ).replace( /\n.*/, '' );
            dmsg( `--> last_chi2 '${last_chi2}'` );
            last_chi2          = last_chi2 === '******' ? '99.999' : last_chi2;
            last_chi2_avail    = true;
            last_chi2_res_line = res;
            dmsg( `--> last_chi2_res_line '${last_chi2_res_line}'` );
        }
    }

    for ( opt in app_texts_scan) {
        0 && dmsg( "get_response_scan_runner() : opt now       : " + JSON.stringify( opt ) );
        var optstring = temp_response[ opt ][ "text" ].replace(/\s+/g,'').replace(/\h+/g,'');
        0 && dmsg( "get_response_scan_runner() : optstring now : " + optstring );
        if ( resstring.indexOf(optstring) >= 0 ) {
            dmsg( "get_response_scan_runner() : opt accepted       : " + JSON.stringify( opt ) );
            if ( opt == "set_parameters" ) {
                response = "Y";
                var currentstep = temp_response[ opt ][ "min" ] ;
                if ( currentstep < maxscansteps ) {
                    dmsg( `get_response_scan_runner() : set_scan_variables_scanner ndx_scan[ currentstep = ${currentstep}] ` + JSON.stringify( ndx_scan[ currentstep ] ) );
                    var result = await set_scan_variables_scanner( ndx_scan[ currentstep ] );
                    0 && dmsg( "get_response_scan_runner() : temp_response : " + JSON.stringify( temp_response, null, 2 ) );
                } else {
                    response = "N";
                };
                temp_response[ opt ][ "min" ] += 1;
                currentstep += 1;
            } else {
                response = temp_response[ opt ][ "response" ].toString();
            };
            if ( opt == "plot_fit" ) {
                let this_step = temp_response[ "set_parameters" ][ "min" ];
                if ( !last_chi2_avail ) {
                    console.error( "--> chi^2 not available" );
                }
                const chi2         = last_chi2;
                // res.replace( /^.*Chi\^2:\s*/, '' ).replace( /\n.*/, '' );
                dmsg( `--> res '${res}'` );
                dmsg( `--> chi2 '${chi2}'` );
                chi2_scan.push( chi2 );
                dmsg( `get_response_scan_runner() : this_step ${this_step} chi2 ${chi2}\n-->chi2_scan ` + JSON.stringify( chi2_scan ) );
                dmsg( `setdata info this_step ${this_step} chi2 value ` + ( +(chi2_scan[ chi2_scan.length - 1 ]) ) );
                
                dmsg( `runname ${runname} cwd ` + process.cwd() );
                this_step ? scandata.setdata( this_step - 1, +(chi2_scan[ chi2_scan.length - 1 ]), [ "int", "fit", "alm" ].map( e => `${runname}/CRYSOL/${pdbbase}00.${e}` ), `${runname}/results` ) : '';
                
                if ( temp_response[ "set_parameters" ][ "min" ] == 0 ) {
                    if ( "constant_subtractions" in req ) { 
                        app_texts_scan[ "constant_subtractions" ][ "response" ] = "Y";
                        temp_response[ "constant_subtractions" ][ "response" ] = "Y"; 
                    };
                    startTime = performance.now();
                    scan_parameter_report( last_chi2_avail ? last_chi2_res_line + res : res );
                    console.info( scan_variables );
                    if ( scandata_mode ) {
                        reset_scandata( scan_variables.length );
                    }
                } else {
                    var exeTime = (Number.parseInt(performance.now() - startTime))/1000;
                    console.log ( "Time per step = " + exeTime + " secs" );
                    console.log ( "Remaining steps = " + ( maxscansteps - temp_response[ "set_parameters" ][ "min" ] ) + " : Expected to finish in " + ( exeTime * ( maxscansteps - temp_response[ "set_parameters" ][ "min" ] ) ).toFixed(2)+ " secs" ); 
                    startTime = performance.now();
                };
                last_chi2_avail    = false;
                last_chi2_res_line = '';
            };
            //            console.log ("UPDATE response: " + response + "\n" );
            source.stdin.write(response + "\n");
            console.log ( "#" + res + "#" + response + "\n");
        };
        
    };

    //         if ( result.length == 0 ) {
    //             result += " No option found from crysol output strings: " + res + "\n";
    //         };
    return result;
}

function readfile_log() {
    return new Promise ( (resolve, reject) => {
        try {
            var files = fs.readdirSync( './' );
            var chi2_data = [];
            files.forEach ( function ( file ) {
                var suffix = file.split( '.' ).pop();
                if ( suffix == "log" ) {
                    var txt = fs.readFileSync( file ).toString().split("\n");
                    for ( var i = 0; i < txt.length; i++ ) {
                        var txttrim = txt[ i ].replace(/\s+/g,'').replace(/\h+/g,'').replace(/-/g,'');
                        if ( txttrim.indexOf( "DroMin" ) >= 0 ) {
                            var istart = i + 2;    // always skip the first chi^2
                        };
                        if ( txttrim.indexOf ( "Radii" ) >= 0 ) {
                            var iend = i - 1;
                        };
                    };
                    for ( var i = istart; i < iend; i++ ) {
                        var txttrim = txt[ i ].toString().replace( /^\s*/,"" ).split(" ");
                        if ( txttrim[0] != "--" ) {
                            //                         console.log ( txttrim + "\n" );
                            //                             chi2_data.push( parseFloat( txttrim[ 15 ] ) ); 
                            var chi2_value = txt[ i ].substring( 66,73 );
                            if ( chi2_value == "*******" ) {
                                chi2_value = "1000.0";
                            };
                            chi2_data.push( parseFloat( txt[ i ].substring( 66,73 ) ) );
                        };
                    };      
                };
            });
            //           console.log ( "CHI2 : " + chi2_data + "\n" );
            resolve( chi2_data );
        } catch (error) {
            reject( error.message );
        };

    });
};

async function write_chi2( nscans, chi2_from_log ) {
    var result = '';
    if ( nscans == 0 ) {
        process.on( 'exit', function(code) { 
            return console.log ( "Number of scan variables is 0." )});
    } else if ( nscans == 1 ) {
        result += await fill_chi2_1d( chi2_from_log );
        //        result += await write_zip( );
    } else { 
        result += await fill_chi2_2d( nscans, chi2_from_log );
        //        result += await write_zip( );
    };
}

function write_zip() {
    return new Promise ( ( resolve, reject ) => {
        var result = '';
        try {
            var zipname = req._base_directory;
            var zipdir = '';
            zipname = pdbshort.split( '.' ).slice( 0,1 ) + "00.zip";
            //    zipname = req._base_directory + "/" + "CRYSOL/" + pdbshort.split('.').slice(0,1) + "00.zip";

            const cmd = "zip -r " + zipname + " " + "*.csv" ;

            exec(cmd,(err,stdout,stderr) => {
                if (err) {
                    result += "Error in zipping csv files :" + err.message + "\n";
                }
            });
            resolve ( result );
        } catch ( error ) {
            reject (error.message);
        };
    });
}

function fill_chi2_1d( chi2_from_log) {
    return new Promise ( ( resolve, reject ) => {
        var result = '';
        var scanfile = pdbshort.split( '.' ).slice( 0,1 ) + "00.scan";

        try {
            var stream = fs.createWriteStream( scan_outfiles[ 0 ] ) ;
            var streamall = fs.createWriteStream( scanfile ) ;
            var filename = scan_outfiles[ 0 ]; 
            var header = filename.split('.').slice(0,1);
            stream.write( [ header, "chi2" ] + "\n" );
            streamall.write( [ header, "chi2" ] + "\n" );
            var imax = parseInt( app_texts_scan[ scan_variables_points[ 0 ] ][ "response" ] );
            for ( var i=0; i < imax; i++ ) {
                var x = parseFloat( app_texts_scan[ scan_variables_low[ 0 ] ][ "response" ] ) + 
                    parseFloat( app_texts_scan[ scan_variables_interval[ 0 ] ][ "response" ] ) * parseFloat( i );
                var y = chi2_from_log[ i ];
                stream.write( [ x, y ] + "\n" ); 
                streamall.write( [ x, y ] + "\n" );
            };
            stream.end();
            streamall.end();

            resolve( result ); 
        } catch( error ) {
            reject( error.message );
        };
    });
}

function fill_chi2_2d( nscans, chi2_from_log) {
    return new Promise ( ( resolve, reject ) => {
        var result = '';
        var scanfile = pdbshort.split( '.' ).slice( 0,1 ) + "00.scan";
        try {
            count = 0;
            total = 0;
            var streamall = fs.createWriteStream( scanfile ) ;
            for ( var i = 0; i < nscans-1; i++ ) {
                var imax = parseInt( app_texts_scan[ scan_variables_points[ i ] ][ "response" ] );
                for ( var j = i + 1; j < nscans; j++ ) {
                    var logcount = 0;
                    var stream = fs.createWriteStream( scan_outfiles[ count ] ) ;
                    var filename = scan_outfiles[ count ];
                    var header = [ filename.split('.').slice(0,1) ];
                    var jmax = parseInt( app_texts_scan[ scan_variables_points[ j ] ][ "response" ] );
                    for ( var jj = 0; jj < jmax; jj++ ) {
                        var temp_v = parseFloat( app_texts_scan[ scan_variables_low[ j ] ][ "response" ] ) +  
                            parseFloat( app_texts_scan[ scan_variables_interval[ j ] ][ "response" ] ) * parseFloat ( jj );
                        header.push( temp_v );
                    }
                    stream.write( header + "\n" );
                    streamall.write( header + "\n" );

                    for ( var ii = 0; ii < imax; ii++ ) {
                        var x = parseFloat( app_texts_scan[ scan_variables_low[ i ] ][ "response" ] ) + 
                            parseFloat( app_texts_scan[ scan_variables_interval[ i ] ][ "response" ] ) * parseFloat( ii );
                        var temp_v = [ x ];
                        for ( var jj = 0; jj < jmax; jj++ ) {
                            var y = chi2_from_log[ total ];
                            temp_v.push( y );
                            logcount += 1;
                            total += 1;
                        };
                        stream.write( temp_v + "\n" );
                        streamall.write(temp_v + "\n" );

                    };
                    count += 1;
                    stream.end();
                };
            };
            streamall.end();
            resolve( result );
        } catch ( error ) {
            reject ( error.message );
        };
    });
}

function set_scan_variables_scanner( nbin ){
    return new Promise ( (resolve, reject) => {
        var result = '';
        //    console.log ( "UPDATE START\n" );
        try {
            for ( var i = 0; i < scan_variables.length; i++ ){
                if ( nbin[ i ] < 0 ) {
                    temp_response[ scan_variables_low[ i ] ][ "response" ] = app_texts_scan[ scan_variables_low[ i ] ][ "response" ];
                    temp_response[ scan_variables_high[ i ] ][ "response" ] = app_texts_scan[ scan_variables_high[ i ] ][ "response" ];
                } else {
                    temp_response[ scan_variables_low[ i ] ][ "response" ] = 
                        parseFloat( app_texts_scan[ scan_variables_low[ i ] ][ "response" ] ) 
                        + parseFloat( app_texts_scan[ scan_variables_interval[ i ] ][ "response" ] ) * parseInt( nbin[ i ] );
                    temp_response[ scan_variables_high[ i ] ][ "response" ] = 
                        parseFloat( app_texts_scan[ scan_variables_low[ i ] ][ "response" ] ) 
                        + parseFloat( app_texts_scan[ scan_variables_interval[ i ] ][ "response" ] ) * parseInt( nbin[ i ] ); 
                };
                dmsg( "set_scan_variables_scanner( " + JSON.stringify(nbin) + " min, max : "
                      + temp_response[ scan_variables_low[ i ] ][ "response" ] + " " +  temp_response[ scan_variables_high[ i ] ][ "response" ] );
            };
            //        result += "UPDATE set_parameters DONE \n";
            resolve(result);
        } catch( error ) {
            //        console.log ( "Error in set up scanning variables.");
            reject( "Error in set up scanning variables." );
        };
        //    console.log("CHECK SCAN VARIABLES " + temp_response[ "set_parameters" ]["min"] + temp_response[ "set_parameters" ]["response"] + " \n");
        //    console.log(JSON.stringify(app_texts_update));

    });
}

function spawn_calc_runner(response_update, maxscansteps) {
    return new Promise ( (resolve, reject) => {
        const source = spawn(cmd, []);

        source.stdout.setEncoding('utf8');

        //    source.stdin.pipe(process.stdout);

        var res = '';
        source.stdout.on( 'data', (data) => {
            var res = data;
            var response = get_response_calc_runner(response_update, source, res, maxscansteps );
            //        source.stdin.write(response + "\n");
            //        resolve (response);
        });

        source.stderr.on( 'data', (data) => {
            //console.log(`Crysol scan error: ${data}`);
        });

        source.on('close', (code) => {
            //console.log(`Crysol scanner exited with code ${code}`);
            //resolve (code);
        });

    });
}

function spawn_fit_runner(response_update, maxscansteps) {
    return new Promise ( (resolve, reject) => {
        const source = spawn(cmd, []);

        source.stdout.setEncoding('utf8');

        //    source.stdin.pipe(process.stdout);

        var maxscansteps = 0;
        var res = '';
        source.stdout.on( 'data', (data) => {
            var res = data;
            var response = get_response_fit_runner(response_update, source, res, maxscansteps );
            //        source.stdin.write(response + "\n");
            //        resolve (response);
        });

        source.stderr.on( 'data', (data) => {
            //console.log(`Crysol scan error: ${data}`);
        });

        source.on('close', (code) => {
            //console.log(`Crysol scanner exited with code ${code}`);
            resolve (code);
        });

    });
}

function spawn_scan_runner( ndx_scan, maxscansteps) {
    return new Promise ( (resolve, reject) => {
        const source = spawn(cmd, []);

        //    app_texts[ "set_parameters" ][ "min" ] = 0;

        var result = '';
        source.stdout.setEncoding('utf8');

        var res = '';
        source.stdout.on( 'data', (data) => {
            var res = data;
            var result = get_response_scan_runner( source, res, ndx_scan, maxscansteps );
            //        source.stdin.write(response + "\n");
            //        resolve (result);
        });

        source.stderr.on( 'data', (data) => {
            //console.log(`Crysol scan error: ${data}`);
        });

        source.on('close', (code) => {
            //console.log(`Crysol scanner exited with code ${code}`);
            resolve (code);
        });

    });
}


async function calc_runner() {

    var maxscansteps = 1;
    var response_update = {};
    response_update = JSON.parse( JSON.stringify( temp_response ) );

    var result = "";
    console.log (JSON.stringify(response_update, null, 2));
    try {
        result += await spawn_calc_runner(response_update,maxscansteps);
    } catch (err) {
        result += err
    }
    return result;
}

async function fit_runner() {

    var maxscansteps = 1;
    var response_update = {};
    response_update = JSON.parse( JSON.stringify( temp_response ) );

    var result = "";
    console.log (JSON.stringify(response_update, null, 2));
    try {
        result += await spawn_fit_runner(response_update,maxscansteps);
    } catch (err) {
        result += err.message;
    }
    return result;
}

async function scan_runner() {

    var result = '';
    //    var ndro = parseInt( temp_response[ "scan_contrast_hydration_points" ][ "response" ] );
    //    var nradius = parseInt( temp_response[ "scan_atomic_radius_points" ][ "response"] );
    //    var nev = parseInt( temp_response[ "scan_excluded_volume_points" ][ "response" ] );

    var scanstep = 0;

    var nscans = await setup_scan();

    var ndx_scan = generate_scan_array( 3, nscans );
    dmsg( 'scan_runner() ndx_scan:\n' + JSON.stringify( ndx_scan ) );
    //    console.log ( "Scanning parameters = " + nscans + " : " + ndx_scan + "\n");
    var maxscansteps = ndx_scan.length;
    
    //    console.log ( "##### Total scanning parameters = " + maxscansteps + "\n" );
    0 && debug && process.exit(-1);
    result += await spawn_scan_runner( ndx_scan, maxscansteps );
    scanstep += 1;
    var chi2_from_log = await readfile_log();

    write_chi2(nscans, chi2_from_log);
    //    console.log( chi2_scan );
    console.log( "# of step = " + maxscansteps + " Done \n" );
    
    if ( scandata_mode ) {
        scandata.write   ( req._base_directory + "/" + pdbshort.split( '.' ).slice( 0,1 ) + "00.scandata" );
        scandata.csvwrite( req._base_directory + "/" + pdbshort.split( '.' ).slice( 0,1 ) + "00.scan.csv" );
    }

    return result;
}

async function crysol_runner() {

    var result = '';
    await initialize();
    console.log( "CRYSOL " + runmode + " Start~~~\n");

    try { 
        if ( runmode == "calc" ){
            result += calc_runner();
        } else if ( runmode == "fit" ) {
            result += fit_runner();
        } else if ( runmode == "scan" ) {
            result += scan_runner();
        };
    } catch (error) {
        result += error.message
    };
}

var angular_units = {
    "CRYSOL" : { "0" : "0", "1" : "1", "2" : "2", "3" : "3", "4" : "4" }
};

var app_texts_calc = {
    "enter_your_option":
    {"text": "Enter your option ........." 
     ,"type": "integer"
     ,"response": "0" }
    ,"pdb": 
    {"text": "Brookhaven file name ................... <" 
     ,"type": "file"
     ,"response": ""}
    ,"experimental_curve":      
    {"text": "Enter data file ......................"
     ,"type": "file"
     ,"response": "N"}
    ,"savfile":      
    {"text": "Save file name ......................... <"
     ,"type": "file"
     ,"response": " "}
    ,"chain_id": 
    {"text": "Process chain (0: all chains) ...."
     ,"type": "integer"
     , "response": ""}
    ,"maxharmonics": 
    {"text": "Maximum order of  harmonics ........... <" 
     ,"type": "integer"
     ,"response": 15}
    ,"fibonacci_grid": 
    {"text": "Order of Fibonacci grid ............... <" 
     ,"type": "integer"
     ,"response": 17}
    ,"qmax": 
    {"text": "Maximum s value ........................ <"
     ,"response": 0.5
     ,"type": "float"
     ,"info": "use for calc mode"}
    ,"smax":
    {"text": "Smax in the fitting range .............. <"
     ,"type": "float"
     ,"response": ""
     ,"info": "use for fit and scan mode"}
    ,"number_of_points": 
    {"text": "Number of points ..............." 
     ,"type": "integer"
     , "response": ""}
    ,"explicit_hydrogen":
    {"text": "Account for explicit hydrogens?"
     ,"type": "checkbox"
     , "response": "N"}
    ,"fit_curve":
    {"text": "Fit the experimental curve"
     ,"type": "character"
     ,"response": "N"}
    ,"solvation_density": 
    {"text": "Electron density of the solvent, e/A**3  <"
     ,"type": "float"
     ,"response": ""}
    ,"angular_units":     
    {"text": "2 *  sin(theta)/lambda [1/nm]  (4) ....."
     ,"type": "listbox"
     ,"response": ""}
    ,"plot_fit":
    {"text": "Plot the fit [ Y / N ]"
     ,"type": "character"
     ,"response": "N"}
    ,"set_parameters": 
    {"text": "Another set of parameters [ Y / N ] ...."
     ,"type": "character"
     ,"response": "N"
     ,"min": 0
    }
    ,"minimize_again": 
    {"text": "Minimize again with new limits [ Y / N ] <"
     ,"type": "boolean"
     ,"response": "Y"}
    ,"fix_contrast_hydration":
    {"text": "Contrast of the solvation shell ......"
     ,"type": "float"
     ,"response": " "  
     ,"min": 0.0
     ,"max": 0.075
     ,"delta": 0.003
     ,"npoints": 2}
    ,"fit_contrast_hydration_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fix_contrast_hydration" ]
     ,"response": " "
    }
    ,"scan_contrast_hydration_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fix_contrast_hydration" ]
     ,"response": " "
    }
    ,"fix_atomic_radius":
    {"text": "Average atomic radius .................. <"
     ,"type": "float"
     ,"response": " "
    }
    ,"fit_atomic_radius_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fix_atomic_radius" ]
     ,"response": " "
    }
    ,"scan_atomic_radius_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fix_atomic_radius" ]
     ,"response": " "
    }
    ,"fix_excluded_volume":
    {"text": "Excluded Volume ................."
     ,"type": "float"
     ,"response": " "
    }
    ,"fit_excluded_volume_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fix_excluded_volume" ]
     ,"response": " "
    }
    ,"scan_excluded_volume_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fix_excluded_volume" ]
     ,"response": " "
    }
    ,"constant_subtractions":
    {"text": "Subtract constant ...................... <"
     ,"type": "checkbox"
     ,"response": "N"}
    ,"averaged_tail":
    {"text": "Averaged tail intensity is ............."
     ,"type": "float"
     ,"response": " "}
    ,"background_min":
    {"text": "Minimum relative background ............ <"
     ,"type": "float"
     ,"response": -0.5}
    ,"background_max":
    {"text": "Maximum relative background ............ <"
     ,"type": "float"
     ,"response": 0.5}
};

var app_texts_fit = {
    "enter_your_option":
    {"text": "Enter your option ........."
     ,"type": "integer"
     ,"response": "0" }
    ,"pdb":           
    {"text": "Brookhaven file name ................... <"
     ,"type": "file"
     ,"response": ""}
    ,"experimental_curve":
    {"text": "Enter data file ......................"
     ,"type": "file"
     ,"response": "N"}
    ,"savfile":       
    {"text": "Save file name ......................... <"
     ,"type": "file"
     ,"response": " "}
    ,"chain_id":      
    {"text": "Process chain (0: all chains) ...."
     ,"type": "integer"
     , "response": ""}
    ,"maxharmonics":  
    {"text": "Maximum order of  harmonics ........... <"
     ,"type": "integer"
     ,"response": 15}
    ,"fibonacci_grid":
    {"text": "Order of Fibonacci grid ............... <"
     ,"type": "integer"
     ,"response": 17}
    ,"qmax":          
    {"text": "Maximum s value ........................ <"
     ,"response": 0.5
     ,"type": "float"
     ,"info": "use for calc mode"}
    ,"smax":          
    {"text": "Smax in the fitting range .............. <"
     ,"type": "float"
     ,"response": ""
     ,"info": "use for fit and scan mode"}
    ,"number_of_points":
    {"text": "Number of points ..............."
     ,"type": "integer"
     , "response": ""}
    ,"explicit_hydrogen":
    {"text": "Account for explicit hydrogens?"
     ,"type": "checkbox"
     , "response": "N"}
    ,"fit_curve":     
    {"text": "Fit the experimental curve"
     ,"type": "character"
     ,"response": "Y"}
    ,"solvation_density":
    {"text": "Electron density of the solvent, e/A**3  <"
     ,"type": "float"
     ,"response": ""}
    ,"angular_units": 
    {"text": "2 *  sin(theta)/lambda [1/nm]  (4) ....."
     ,"type": "listbox"
     ,"response": ""}
    ,"plot_fit":      
    {"text": "Plot the fit [ Y / N ]"
     ,"type": "character"
     ,"response": "N"}
    ,"set_parameters":
    {"text": "Another set of parameters [ Y / N ] ...."
     ,"type": "character"
     ,"response": "N"
     ,"min": 0
    }
    ,"minimize_again":
    {"text": "Minimize again with new limits [ Y / N ] <"
     ,"type": "boolean"
     ,"response": "Y"}
    ,"fit_contrast_hydration_low":
    {"text": "Minimum contrast in the shell .......... <"
     ,"type": "float"
     ,"response": " "}
    ,"fit_contrast_hydration_high":
    {"text": "Maximum contrast in the shell .......... <"
     ,"type": "float"
     ,"response": " "}
    ,"fix_contrast_hydration":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_contrast_hydration_low", "fit_contrast_hydration_high" ]
     ,"response": " "}
    ,"scan_contrast_hydration_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_contrast_hydration_low" ]
     ,"response": " "}
    ,"scan_contrast_hydration_high":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_contrast_hydration_high" ]
     ,"response": " "}
    ,"fit_atomic_radius_low":
    {"text": "Minimum radius of atomic group ......... <"
     ,"type": "float"
     ,"response": " "}
    ,"fit_atomic_radius_high": 
    {"text": "Maximum radius of atomic group ......... <"
     ,"type": "float"
     ,"response": " "}
    ,"fix_atomic_radius":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_atomic_radius_low", "fit_atomic_radius_high" ]
     ,"response": " "}
    ,"scan_atomic_radius_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_atomic_radius_low" ]
     ,"response": " "}
    ,"scan_atomic_radius_high":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_atomic_radius_high" ]
     ,"response": " "}
    ,"fit_excluded_volume_low":
    {"text": "Minimum excluded volume ................ <"
     ,"type": "float"
     ,"response": " "}
    ,"fit_excluded_volume_high":
    {"text": "Maximum excluded volume ................ <"
     ,"type": "float"
     ,"response": " " }
    ,"fix_excluded_volume":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_excluded_volume_low", "fit_excluded_volume_high" ]
     ,"response": " "}
    ,"scan_excluded_volume_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_excluded_volume_low" ]
     ,"response": " "}
    ,"scan_excluded_volume_high":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "fit_excluded_volume_high" ]
     ,"response": " "}
    ,"constant_subtractions":
    {"text": "Subtract constant ...................... <"
     ,"type": "checkbox"
     ,"response": "N"}
    ,"averaged_tail":
    {"text": "Averaged tail intensity is ............."
     ,"type": "float"
     ,"response": " "}
    ,"background_min":
    {"text": "Minimum relative background ............ <"
     ,"type": "float"
     ,"response": -0.5}
    ,"background_max":
    {"text": "Maximum relative background ............ <"
     ,"type": "float"
     ,"response": 0.5}
};

var app_texts_scan = {
    "enter_your_option":
    {"text": "Enter your option ........."
     ,"type": "integer"
     ,"response": "0" }
    ,"pdb":
    {"text": "Brookhaven file name ................... <"
     ,"type": "file"
     ,"response": ""}
    ,"experimental_curve":
    {"text": "Enter data file ......................"
     ,"type": "file"
     ,"response": "N"}
    ,"savfile":
    {"text": "Save file name ......................... <"
     ,"type": "file"
     ,"response": " "}
    ,"chain_id":
    {"text": "Process chain (0: all chains) ...."
     ,"type": "integer"
     , "response": ""}
    ,"maxharmonics":
    {"text": "Maximum order of  harmonics ........... <"
     ,"type": "integer"
     ,"response": 15}
    ,"fibonacci_grid":
    {"text": "Order of Fibonacci grid ............... <"
     ,"type": "integer"
     ,"response": 17}
    ,"qmax":
    {"text": "Maximum s value ........................ <"
     ,"response": 0.5
     ,"type": "float"
     ,"info": "use for calc mode"}
    ,"smax":
    {"text": "Smax in the fitting range .............. <"
     ,"type": "float"
     ,"response": ""
     ,"info": "use for fit and scan mode"}
    ,"number_of_points":
    {"text": "Number of points ..............."
     ,"type": "integer"
     , "response": ""}
    ,"explicit_hydrogen":
    {"text": "Account for explicit hydrogens?"
     ,"type": "checkbox"
     , "response": "N"}
    ,"fit_curve":
    {"text": "Fit the experimental curve"
     ,"type": "character"
     ,"response": "Y"}
    ,"solvation_density":
    {"text": "Electron density of the solvent, e/A**3  <"
     ,"type": "float"
     ,"response": ""}
    ,"angular_units":
    {"text": "2 *  sin(theta)/lambda [1/nm]  (4) ....."
     ,"type": "listbox"
     ,"response": ""}
    ,"plot_fit":
    {"text": "Plot the fit [ Y / N ]"
     ,"type": "character"
     ,"response": "N"}
    ,"set_parameters":
    {"text": "Another set of parameters [ Y / N ] ...."
     ,"type": "character"
     ,"response": "N"
     ,"min": 0
    }
    ,"minimize_again":
    {"text": "Minimize again with new limits [ Y / N ] <"
     ,"type": "boolean"
     ,"response": "Y"}
    ,"scan_contrast_hydration_low":
    {"text": "Minimum contrast in the shell .......... <"
     ,"type": "float"
     ,"response": " "}
    ,"scan_contrast_hydration_high":
    {"text": "Maximum contrast in the shell .......... <"
     ,"type": "float"
     ,"response": " "}
    ,"scan_contrast_hydration_points":
    {"text" : "PLACE HOLDER"
     ,"type": "integer"
     ,"response": 0 } // 1 is used as flag to exclude from scanning 
    ,"scan_contrast_hydration_interval":
    {"text" : "PLACE HOLDER"
     ,"type": "float"
     ,"response": " "}
    ,"fix_contrast_hydration":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_contrast_hydration_low", "scan_contrast_hydration_high" ]
     ,"response": " "
    }
    ,"fit_contrast_hydration_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_contrast_hydration_low" ]
     ,"response": " "
    }
    ,"fit_contrast_hydration_high":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_contrast_hydration_high" ]
     ,"response": " "
    }
    ,"scan_atomic_radius_low":
    {"text": "Minimum radius of atomic group ......... <"
     ,"type": "float"
     ,"response": " "}
    ,"scan_atomic_radius_high":
    {"text": "Maximum radius of atomic group ......... <"
     ,"type": "float"
     ,"response": " "}
    ,"scan_atomic_radius_points":
    {"text" : "PLACE HOLDER"
     ,"type": "integer"
     ,"response": 0 }
    ,"scan_atomic_radius_interval":
    {"text" : "PLACE HOLDER"
     ,"type": "float"
     ,"response": " "}
    ,"fix_atomic_radius":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_atomic_radius_low", "scan_atomic_radius_high" ]
     ,"response": " "
    }
    ,"fit_atomic_radius_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_atomic_radius_low" ]
     ,"response": " "
    }
    ,"fit_atomic_radius_high":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_atomic_radius_high" ]
     ,"response": " "
    }
    ,"scan_excluded_volume_low":
    {"text": "Minimum excluded volume ................ <"
     ,"type": "float"
     ,"response": " "}
    ,"scan_excluded_volume_high":
    {"text": "Maximum excluded volume ................ <"
     ,"type": "float"
     ,"response": " " }
    ,"scan_excluded_volume_points":
    {"text" : "PLACE HOLDER"
     ,"type": "integer"
     ,"response": 0 }
    ,"scan_excluded_volume_interval":
    {"text" : "PLACE HOLDER"
     ,"type": "float"
     ,"response": " "}
    ,"fix_excluded_volume":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_excluded_volume_low", "scan_excluded_volume_high" ]
     ,"response": " "
    }
    ,"fit_excluded_volume_low":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_excluded_volume_low" ]
     ,"response": " "
    }
    ,"fit_excluded_volume_high":
    {"text": "DUMMY PLACE HOLDER"
     ,"id": [ "scan_excluded_volume_high" ]
     ,"response": " "
    }
    ,"constant_subtractions":
    {"text": "Subtract constant ...................... <"
     ,"type": "checkbox"
     ,"response": "N"}
    ,"averaged_tail":
    {"text": "Averaged tail intensity is ............."
     ,"type": "float"
     ,"response": " "}
    ,"background_min":
    {"text": "Minimum relative background ............ <"
     ,"type": "float"
     ,"response": -0.5}
    ,"background_max":
    {"text": "Maximum relative background ............ <"
     ,"type": "float"
     ,"response": 0.5}
};

var temp_response = {};
var scan_table = {
    "contrast_hydration" :  {
        "mode" : "contrast_hydration_mode"
        ,"low"    : "scan_contrast_hydration_low"
        ,"high"    : "scan_contrast_hydration_high"
        ,"interval"    : "scan_contrast_hydration_interval"
        ,"points"    : "scan_contrast_hydration_points"
        ,"scale"     : 1.0
    }
    ,"atomic_radius"      :  {
        "mode" : "atomic_radius_mode" 
        ,"low"    : "scan_atomic_radius_low"
        ,"high"    : "scan_atomic_radius_high"
        ,"interval"    : "scan_atomic_radius_interval"
        ,"points"    : "scan_atomic_radius_points"
        ,"scale"     : 1.0
    }
    ,"excluded_volume"    : {
        "mode" : "excluded_volume_mode"
        ,"low"    : "scan_excluded_volume_low"
        ,"high"    : "scan_excluded_volume_high"
        ,"interval"    : "scan_excluded_volume_interval"
        ,"points"    : "scan_excluded_volume_points"
        ,"scale"     : 1.0
    }
}


var scan_variables          = [];
var scan_variables_low      = [];
var scan_variables_high     = [];
var scan_variables_interval = [];
var scan_variables_points   = [];
var scan_variables_scale    = [];

var nonscan_variables       = [];
var scan_outfiles           = [];

function setup_scan() {
    return new Promise ( (resolve, reject) => { 

        dmsg( "setup_scan()" );
        dmsg( "scan_table\n" + JSON.stringify( scan_table, null, 2 ) );
        try {

            for ( opt in scan_table ) {
                if ( scan_table[ opt ][ "mode" ] in req ) {
                    if ( req [scan_table[ opt ][ "mode" ]] == "4" || req [scan_table[ opt ][ "mode" ]] == "5" ) {
                        scan_variables.push( opt );
                        scan_variables_low.push( scan_table[ opt ][ "low" ] );
                        scan_variables_high.push( scan_table[ opt ][ "high" ] );
                        scan_variables_interval.push( scan_table[ opt ][ "interval" ] );
                        scan_variables_points.push( scan_table[ opt ][ "points" ] );
                        scan_variables_scale.push( scan_table[ opt ][ "scale" ] );
                    };
                } else {
                    nonscan_variables.push( opt );
                };
                
                //        };
            };
            var num_scan = scan_variables.length;

            dmsg( "scan_variables: " + JSON.stringify( scan_variables ) );

            for ( var i=0; i < nonscan_variables.length; i++ ) {
                scan_variables.push( nonscan_variables[ i ] );
                scan_variables_low.push( scan_table[ nonscan_variables[ i ] ][ "low" ] );
                scan_variables_high.push( scan_table[ nonscan_variables[ i ] ][ "high" ] );
                scan_variables_interval.push( scan_table[ nonscan_variables[ i ] ][ "interval" ] );
                scan_variables_points.push( scan_table[ nonscan_variables[ i ] ][ "points" ] );
                scan_variables_scale.push( scan_table[ nonscan_variables[ i ] ][ "scale" ] );
            };

            if ( num_scan == 1 ) {
                var filename = scan_variables[ 0 ].toString() + ".csv";
                scan_outfiles.push( filename );
            } else {
                for ( var i=0; i < num_scan - 1; i++ ) {
                    for ( var j=i+1; j < num_scan; j++ ) {
                        var filename = scan_variables[ i ].toString() + "-" + scan_variables[ j ].toString() + ".csv";
                        scan_outfiles.push( filename );
                    };
                };
            };

            console.log ( "Scanning parameters\n");
            dmsg        ( "scan_variables: " + JSON.stringify( scan_variables) + "\n");
            console.log ( "scan_variables_low: " + JSON.stringify( scan_variables_low ) + "\n");
            console.log ( "scan_variables_high: " + JSON.stringify( scan_variables_high ) + "\n");
            dmsg        ( "scan_variables_interval: " + JSON.stringify( scan_variables_interval ) + "\n");
            console.log ( "scan_variables_points: " + JSON.stringify( scan_variables_points ) + "\n");
            dmsg        ( "scan_variables_scale: " + JSON.stringify( scan_variables_scale ) + "\n");
            dmsg        ( "scan_outfiles: " + JSON.stringify( scan_outfiles ) + "\n");
            0 && debug && process.exit(-1);
            resolve( num_scan );
        } catch ( error ) {
            reject( error.message ); 
        };
        
    });
}

function reset_scandata( nscan ) {
    scandata.defaults( "multisaxshub",
                       {
                           title : "CRYSOL chi^2 scan data"
                           ,titlehtml : 'CRYSOL <i style="font-family:georgia">&#935;</i><sup>2</sup> scan data'
                       } );

    for ( var i = 0; i < nscan; ++i ) {
        var vals = [];
        for ( var j = 0; j < app_texts_scan[ scan_variables_points[ i ] ][ "response" ]; ++j ) {
            vals.push( +app_texts_scan[ scan_variables_low[ i ] ][ "response" ]
                       + +app_texts_scan[ scan_variables_interval[ i ] ][ "response" ] * j );
        }
        
        scandata.addparam(
            {
                name     : scan_variables_points[ i ].replace( /(^scan_|_points$)/g, '' )
                ,namehtml : scandata.namehtml( scan_variables_points[ i ].replace( /(^scan_|_points$)/g, '' ) )
                ,val      : vals
                ,format   : (x) => Math.round( x * 1000 ) / 1000
            }
        );
    }
}    

/**
 * creates an array of indices to scan parameters
 * @param {Number} total number of parameters (possible?) to scan
 * @param {Number} total number of scans
 * @returns {Array<Array<Number>>} indices ?
 */
function generate_scan_array( ntotal, nscan ){
    var newarray = [];

    dmsg( `generate_scan_array( ntotal=${ntotal}, nscan=${nscan})` );
    dmsg( 'scan_variables_points\n' + JSON.stringify( scan_variables_points ) );
    
    dmsg( "generate_scan_array\n" + JSON.stringify( app_texts_scan, null, 2 ) );
    if ( nscan == 1 ) {
        var imax = app_texts_scan[ scan_variables_points[ 0 ] ][ "response" ];
        for ( var i=0; i < imax ; i++ ) {
            var temp_arr = [i, -1, -1];
            newarray.push( temp_arr );
            //console.log( "#### nscan = " + nscan + " : " +   imax  + " " + temp_arr );
        } 

    } else if ( nscan > 1 ) {
        for ( var i=0; i < nscan - 1; i++ ) {
            var imax = app_texts_scan[ scan_variables_points[ i ] ][ "response" ];
            for ( var j=i+1; j < nscan ; j++ ) {
                var jmax = app_texts_scan[ scan_variables_points[ j ] ][ "response" ];
                //console.log (imax, jmax);
                for ( var ii = 0; ii < imax; ii++ ) {
                    for ( var jj = 0; jj < jmax; jj++ ) {
                        var temp_arr = [ -1, -1, -1 ];
                        temp_arr[i] = ii;
                        temp_arr[j] = jj;
                        newarray.push( temp_arr );
                        //console.log( temp_arr);
                    };
                };
            };
        };
    };

    // alternate scan data setup
    reset_scandata( nscan );

    if ( nscan == 3 ) {
        // redo newarray
        scandata_mode = true;
        newarray      = scandata.indices();
    }

    dmsg( "scandata.list():" );
    debug && scandata.list();
    dmsg( 'newarray:\n' + JSON.stringify( newarray ) );
    0 && debug && process.exit();
    return newarray;
}

var chi2_scan = [];
//var scan_variables = [ "dro"];
//crysol_runner("fast_scan");
crysol_runner();
